<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">
<title>Secure AutoConnect Chat</title>
<style>
body { font-family: Arial; margin:20px; }
#log { width:100%; height:300px; border:1px solid #aaa; padding:10px; overflow:auto; }
input { width:100%; margin-top:10px; }
button { margin-top:5px; }
</style>
</head>
<body>

<h2>Secure Auto-Connect Chat</h2>
<div id="status">Connectingâ€¦</div>

<div id="chat" style="display:none;">
    <div id="log"></div>
    <input id="msg" placeholder="Type message...">
    <button onclick="sendMsg()">Send</button>
</div>

<script src="https://www.gstatic.com/firebasejs/8.10.0/firebase-app.js"></script>
<script src="https://www.gstatic.com/firebasejs/8.10.0/firebase-database.js"></script>

<script>
// ðŸ”¥ REPLACE THIS WITH YOUR OWN FIREBASE CONFIG
const firebaseConfig = {

  apiKey: "AIzaSyA_TIewvo2zNRJUgH0LzFDWtIhk3Lo9F9Y",

  authDomain: "chatty-8c8f5.firebaseapp.com",

  databaseURL: "https://chatty-8c8f5-default-rtdb.firebaseio.com",

  projectId: "chatty-8c8f5",

  storageBucket: "chatty-8c8f5.firebasestorage.app",

  messagingSenderId: "299726638202",

  appId: "1:299726638202:web:3c8cb755292f14add0bfc3"

};

firebase.initializeApp(firebaseConfig);
const db = firebase.database();

// AES-256 key for E2E encryption
let key;
(async () => {
    key = await crypto.subtle.generateKey(
        {name: "AES-GCM", length: 256},
        true,
        ["encrypt", "decrypt"]
    );
})();

const room = "room1"; // only two users in this room
let pc = new RTCPeerConnection({
    iceServers: [
        { urls: "stun:stun.l.google.com:19302" }
    ]
});

let channel;
let iceQueue = [];

function log(text){
    const box = document.getElementById("log");
    box.innerHTML += text + "<br>";
    box.scrollTop = box.scrollHeight;
}

async function encrypt(text){
    const iv = crypto.getRandomValues(new Uint8Array(12));
    const encoded = new TextEncoder().encode(text);
    const ciphertext = await crypto.subtle.encrypt({name:"AES-GCM", iv}, key, encoded);
    return {
        ct: btoa(String.fromCharCode(...new Uint8Array(ciphertext))),
        iv: btoa(String.fromCharCode(...iv))
    };
}

async function decrypt(obj){
    const ct = Uint8Array.from(atob(obj.ct), c=>c.charCodeAt(0));
    const iv = Uint8Array.from(atob(obj.iv), c=>c.charCodeAt(0));
    const plain = await crypto.subtle.decrypt({name:"AES-GCM", iv}, key, ct);
    return new TextDecoder().decode(plain);
}

function sendMsg(){
    const text = document.getElementById("msg").value;
    encrypt(text).then(e=>{
        channel.send(JSON.stringify(e));
        log("You: " + text);
        document.getElementById("msg").value = "";
    });
}

// ICE candidate handling
pc.onicecandidate = e => {
    if(e.candidate){
        db.ref(room + "/ice").push(JSON.stringify(e.candidate));
    }
};

pc.ondatachannel = e => {
    channel = e.channel;
    channel.onmessage = async msg => {
        const data = JSON.parse(msg.data);
        const text = await decrypt(data);
        log("Them: " + text);
    };
    channel.onopen = () => {
        document.getElementById("chat").style.display = "block";
        document.getElementById("status").innerText = "Connected!";
    };
};

// Listen for incoming ICE candidates
const roomRef = db.ref(room);
roomRef.child("ice").on("child_added", snap => {
    const candidate = JSON.parse(snap.val());
    if(pc.remoteDescription){
        pc.addIceCandidate(new RTCIceCandidate(candidate));
    } else {
        iceQueue.push(candidate);
    }
});

async function flushIceQueue(){
    for(let c of iceQueue){
        await pc.addIceCandidate(new RTCIceCandidate(c));
    }
    iceQueue = [];
}

// Signaling
(async ()=>{
    const snapshot = await roomRef.once("value");
    if(!snapshot.exists()){
        // first user -> create data channel
        channel = pc.createDataChannel("chat");
        channel.onmessage = async msg => {
            const data = JSON.parse(msg.data);
            const text = await decrypt(data);
            log("Them: " + text);
        };
        channel.onopen = () => {
            document.getElementById("chat").style.display = "block";
            document.getElementById("status").innerText = "Connected!";
        };

        const offer = await pc.createOffer();
        await pc.setLocalDescription(offer);
        await roomRef.set({offer: JSON.stringify(offer)});
    } else {
        // second user -> respond
        const offer = JSON.parse(snapshot.val().offer);
        await pc.setRemoteDescription(offer);
        await flushIceQueue();

        const answer = await pc.createAnswer();
        await pc.setLocalDescription(answer);
        await roomRef.child("answer").set(JSON.stringify(answer));
        document.getElementById("chat").style.display = "block";
        document.getElementById("status").innerText = "Connected!";
    }

    // Listen for answer
    roomRef.child("answer").on("value", async snap => {
        if(snap.exists() && !pc.remoteDescription){
            const answer = JSON.parse(snap.val());
            await pc.setRemoteDescription(answer);
            await flushIceQueue();
            document.getElementById("chat").style.display = "block";
            document.getElementById("status").innerText = "Connected!";
        }
    });

})();
</script>
</body>
</html>

